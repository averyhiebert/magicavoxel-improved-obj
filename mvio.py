''' Script for separating MagicaVoxel model into multiple materials and
fixing the UV values so that textures can be applied to materials in a
semi-reasonable manner, instead of the atlas-based approach.'''

import re
import sys
import os

from PIL import Image
import numpy as np

HEADER_COMMENT = "# from Avery Hiebert's MagicaVoxel-improved-obj script."


def load_obj_file(fname):
    ''' Load the object file with the given file name.
    Assumptions:
     - object file is generated by MagicaVoxel (v0.99.4.2 tested)

    Returns:
     - list of texture coordinates
     - list of vertex normals
     - list of 3D vertices
     - list of faces, as tuples of indices (vertex, texture, normal)
     - Image texture, as an array
    '''

    with open(fname,"r") as f:
        #obj_lines = f.readlines()
        obj_file = f.read()
    # Image filename assumption based on MV output
    texture = np.array(Image.open(f"{fname[:-4]}.png"))/255

    # TODO Make this more DRY

    # Get texture coords
    vt_strs = re.findall(r"^vt\s+([-e0-9.]+)\s+([-e.0-9]+)\s*$",
        obj_file,re.MULTILINE)
    vts = np.array(vt_strs,dtype="float")

    # Get vertex normals
    vn_strs = re.findall(r"^vn\s+([-e0-9.]+)\s+([-e.0-9]+)\s+([-e.0-9]+)\s*$",
        obj_file,re.MULTILINE)
    vns = np.array(vn_strs,dtype="float")

    # Get 3D vertices
    v_strs = re.findall(r"^v\s+([-e0-9.]+)\s+([-e.0-9]+)\s+([-e.0-9]+)\s*$",
        obj_file,re.MULTILINE)
    vs = np.array(v_strs,dtype="float")

    # Get faces
    face_strs = re.findall(r"^f\s+(\d+/\d+/\d+)\s+(\d+/\d+/\d+)\s+(\d+/\d+/\d+)\s*$",
        obj_file,re.MULTILINE)
    faces = np.array([[s.split("/") for s in face] for face in face_strs],
        dtype=int)

    return vs, vts, vns, faces, texture

def get_material_list(vts,texture):
    '''
    Create a list of materials (characterized by albedo colour) from the
    given obj file.

    MagicaVoxel creates a texture which is an atlas of colours in a palette,
    and sets the vts for a face to point to the corresponding pixel.
    So for each unique vt, we will create a palette.

    Returns a list of [r,g,b] values (in range 0 to 1).
    '''
    # Sample from texture using x values
    indices = (vts[:,0]*texture.shape[1]).astype("int")
    return texture[0,:,0:3][indices]

def write_mtl_file(fname,materials):
    ''' Given list of material colours, write a materials file with
    the given file path.'''
    lines = [HEADER_COMMENT,"\n"]
    for i, (r,g,b) in enumerate(materials):
        lines.extend([f"newmtl mtl{i}",f"Kd {r} {g} {b}","\n"])

    with open(fname,"w") as f:
        f.write("\n".join(lines))

def fix_texture_coordinates(vs,vts,vns,faces):
    ''' Return new list of texture coordinates and faces, such that
    the texture coordinates are given by projecting points onto 2D plane
    through axis given by normal vector.'''
    # This is a mess, sorry
    new_faces = faces.copy()

    # Normalizing to ensure UV values stay between 0 and 1
    normalized_vs = vs - vs.min(axis=0) # No negative values, some corner is 0
    normalized_vs = normalized_vs/np.abs(normalized_vs).max() # No values over 1

    new_vts = []
    vts_dict = {}

    scale_factor = 1.0 / np.abs(vs).max()

    # No fancy vectorization here, it would be too confusing.
    for f, i in np.ndindex(new_faces.shape[:2]):
        vertex_index, _, normal_index = faces[f,i]
        normal = vns[normal_index-1] # Recall: not 0-indexed
        vertex = normalized_vs[vertex_index-1]

        # Figure out new texture coord
        # Note: since this is magicavoxel, I assume each normal vector
        #  is a (signed) basis vector
        if normal[0] != 0:
            new_vt = (vertex[1],vertex[2])
        elif normal[1] != 0:
            new_vt = (vertex[0],vertex[2])
        else:
            new_vt = (vertex[0],vertex[1])

        if new_vt in vts_dict:
            texture_ind = vts_dict[new_vt]
        else:
            vts_dict[new_vt] = len(new_vts)
            new_vts.append(new_vt)

        new_faces[f,i,1] = vts_dict[new_vt] + 1

    return new_vts, new_faces

def convert_obj_file(f_in,f_out=None):
    ''' Load the specified object file and rewrite in desired format.'''
    # TODO Check that this is a MagicaVoxel output, not the output of
    #  this script itself.

    # Handle filename stuff
    if not f_out:
        f_out = f_in
    base_name = f_out[:-4] # (remove .obj, needed for .mtl file)
    slug = f_out.split("/")[-1][:-4] # i.e. no path or extension

    # Load the file
    vs, vts, vns, faces, texture = load_obj_file(fname=f_in)

    # Start writing file
    file_lines = [
        HEADER_COMMENT,"\n",
        "# group",
        f"o {slug}\n",
        "# material file",
        f"mtllib {slug}.mtl",
    ]

    # Materials handling stuff =================================
    #  (TODO make more modular?)
    # Create list of colours for each material 
    materials = get_material_list(vts,texture)
    material_indices = np.arange(len(materials))
    # Save mtl file
    write_mtl_file(f"{base_name}.mtl",materials)

    # Which material does each face get?
    #  (-1 since .obj vertices are indexed from 1)
    face_materials = faces[:,0,1] - 1 

    # Writing vertices and faces ==============================

    # Write normals
    file_lines.append("\n# normals")
    file_lines.extend(f"vn {vn[0]} {vn[1]} {vn[2]}" for vn in vns)

    #  TODO The fixing of the texture coordinates
    vts, faces = fix_texture_coordinates(vs,vts,vns,faces)

    # Write texture coordinates
    #  (Currently everything is 0,0)
    file_lines.append("\n# texture coordinates")
    file_lines.extend(f"vt {vt[0]} {vt[1]}" for vt in vts)

    # Write vertices
    file_lines.append("\n# vertices")
    file_lines.extend(f"v {v[0]} {v[1]} {v[2]}" for v in vs)

    # Write faces for each material, with usemtl in between
    file_lines.append("\n# faces")
    for i, _ in enumerate(materials):
        file_lines.append(f"usemtl mtl{i}")
        applicable_faces = faces[face_materials == i]
        file_lines.extend(f"f {a}/{b}/{c} {d}/{e}/{f} {g}/{h}/{j}" 
            for (a,b,c), (d,e,f), (g,h,j) in applicable_faces)

    # Write the final .obj file
    file_text = "\n".join(file_lines)
    with open(f_out,"w") as f:
        f.write("\n".join(file_lines))

def is_obj(fname):
    return fname[-4:] == ".obj"

def process_dir(dir_in,dir_out=None):
    if not dir_out:
        dir_out = dir_in
    elif not os.path.isdir(dir_out):
        os.mkdir(dir_out)

    files = os.listdir(dir_in)
    for f in files:
        if is_obj(f):
            convert_obj_file(f"{dir_in}/{f}",f_out=f"{dir_out}/{f}")

if __name__=="__main__":
    if len(sys.argv) < 2 or sys.argv[1].lower() in ["help","h"]:
        print("Usage: ")
        print("\tpython mvio.py input_path [output_path]\n")
        print("Input path can be a .obj file or a directory.")
        print("Output path is optional, and defaults to be same as input.")
        print(" (i.e. the original file will be overwritten in this case)")
        print("If specified, output must match type of input.")
        print(" (i.e. both files or both directories)")
        sys.exit(0)

    if len(sys.argv) == 2:
        file_in = sys.argv[1]
        if is_obj(file_in):
            convert_obj_file(file_in)
        else:
            process_dir(file_in)
    else:
        file_in = sys.argv[1]
        file_out = sys.argv[2]
        if is_obj(file_in) == is_obj(file_out):
            if is_obj(file_in):
                convert_obj_file(file_in,f_out=file_out)
            else:
                process_dir(file_in,file_out)
        else:
            print("Input and output must be of same type.")
            sys.exit(0)
